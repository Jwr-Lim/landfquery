ALTER PROC USP_POP_004_MATERIAL_QUERY3(
 --DECLARE
     @DIV_CD           NVARCHAR(10)    = '01'
    ,@PLANT_CD         NVARCHAR(10)    = '1130'
    ,@WC_CD            NVARCHAR(10)    = '13GA'
    ,@LINE_CD          NVARCHAR(20)    = '13G01A'
    ,@PROC_CD          NVARCHAr(10)    = 'AI' 
    ,@EQP_CD           NVARCHAR(50)    = 'LFG-MSTS-09-02'  -- LFG-MST-10-02,LFG-MSTS-09-02
)
AS

/*
1. 배정이냐 아니냐를 판단한다.
2. 배정 리스트 표기
3. 재고 리스트 표기
*/

-- 1. 배정이냐 아니냐를 판단한다. 4000 인것 처리
-- (1) 오더정보의 공정 순서 확인 -- 투입이 첫번째가 아니다? 이걸 확인해야 함. 

-- 현재 공정의 최종 실적을 먼저 가지고 와서
-- 이게 앞 투입 공정의 실적과 동일한가?
-- 공정 순서를 먼저 체크한다. 앞에 투입이 있나? 
-- 추후 소분은 어떻게 할지 고민 

DECLARE @REQ_DT        NVARCHAR(10) = CONVERT(NVARCHAR(7), GETDATE(), 120)

DECLARE @NOW_ORDER     NVARCHAR(50) = ''   -- 현재 오더 및 REVISION
       ,@NOW_ORDER_REV INT 
       ,@BATCH_CHK     NVARCHAR(1)  = 'N'  -- 배정 여부

IF EXISTS(
  SELECT TOP 1 A.* FROM BA_PROC_MAIN A 
  WHERE A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD 
    AND A.WC_CD = @WC_CD AND A.PROC_SEQ < (
  SELECT A1.PROC_SEQ FROM BA_PROC_MAIN A1 WITH (NOLOCK) 
  WHERE A1.WC_CD = @WC_CD 
  AND A1.PROC_CD = @PROC_CD   
  )
  AND A.IN_GBN = 'I'
  ORDER BY A.PROC_SEQ DESC 
)
BEGIN 
  -- 앞에 투입 공정이 있는경우 
  -- 현재 실적과, 앞투입 실적 오더가 동일한지를 체크 한다.

  DECLARE  
           @BE_PROC_CD        NVARCHAR(10)        -- 이전 공정
          ,@PROC_ORDER        NVARCHAR(50)        -- 현재 마지막 실적 오더번호
          ,@PROC_ORDER_REV    INT                 -- 현재 마지막 실적 REVISION
          ,@PROC_GROUP        NVARCHAR(50)        -- 현재 마지막 실적 그룹번호
          ,@SDATE             DATETIME            -- 현재 마지막 실적 시작시간

          ,@BE_PROC_ORDER     NVARCHAR(50)        -- 이전 공정 마지막 실적 오더번호
          ,@BE_PROC_ORDER_REV INT                 -- 이전 공정 마지막 실적 REVISION
          ,@BE_PROC_GROUP     NVARCHAR(50)        -- 이전 공정 마지막 실적 그룹번호
          ,@BE_SDATE          DATETIME            -- 이전 공정 마지막 실적 시작시간
 
  SELECT TOP 1 @BE_PROC_CD = A.PROC_CD FROM BA_PROC_MAIN A 
  WHERE A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD 
    AND A.WC_CD = @WC_CD AND A.PROC_SEQ < (
  SELECT A1.PROC_SEQ FROM BA_PROC_MAIN A1 WITH (NOLOCK) 
  WHERE A1.WC_CD = @WC_CD 
  AND A1.PROC_CD = @PROC_CD   
  )
  AND A.IN_GBN = 'I'
  ORDER BY A.PROC_SEQ DESC 

  SELECT TOP 1 @PROC_ORDER = A.ORDER_NO, @PROC_ORDER_REV = A.REVISION, @PROC_GROUP = A.PROC_NO, @SDATE = A.SDATE FROM PD_RESULT A WITH (NOLOCK) 
  WHERE A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD AND A.WC_CD = @WC_CD AND A.LINE_CD = @LINE_CD AND A.PROC_CD = @PROC_CD
    --AND A.EDATE IS NOT NULL
  ORDER BY A.SDATE DESC 

  SELECT TOP 1 @BE_PROC_ORDER = A.ORDER_NO, @BE_PROC_ORDER_REV = A.REVISION, @BE_PROC_GROUP = A.PROC_NO, @BE_SDATE = A.SDATE FROM PD_RESULT A WITH (NOLOCK) 
  WHERE A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD AND A.WC_CD = @WC_CD AND A.LINE_CD = @LINE_CD AND A.PROC_CD = @BE_PROC_CD 
    --AND A.EDATE IS NOT NULL
  ORDER BY A.SDATE DESC 
  
  -- 24시간이 지난 데이터가 아니라면? 
  -- 앞에 실적을 따라간다

  SET @BE_SDATE = ISNULL(@BE_SDATE, DATEADD(DAY,-1,@SDATE)) 
  -- 24시간 체크
--  SELECT @SDATE, @BE_SDATE
  IF DATEADD(DAY,-1,@SDATE) < @BE_SDATE 
  BEGIN 
    -- 안에 있으면? 
    -- 오더를 따라간다 같은지 다른지를 확인

    --SELECT @PROC_ORDER, @PROC_ORDER_REV, @PROC_GROUP, @SDATE 
    --SELECT @BE_PROC_ORDER, @BE_PROC_ORDER_REV, @BE_PROC_GROUP, @BE_SDATE 

    IF @PROC_ORDER <> @BE_PROC_ORDER AND @PROC_GROUP <> @BE_PROC_GROUP
    BEGIN 
      SET @NOW_ORDER = @BE_PROC_ORDER
      SET @NOW_ORDER_REV = @BE_PROC_ORDER_REV 
    END 
    ELSE 
    BEGIN 
      SET @NOW_ORDER = @PROC_ORDER
      SET @NOW_ORDER_REV = @PROC_ORDER_REV 
    END 
  END   
END 
ELSE 
BEGIN 

  -- 현재 배정의 가장 최신의 투입 상태의 오더를 가지고 온다. 배정이 있으면...
  -- 투입될 배정이 없으면, 가장 마지막 배정 리스트의 오더를 가지고 온다. 
  
  IF EXISTS(
    SELECT *FROM MT_ITEM_OUT_BATCH A WITH (NOLOCK) 
    WHERE A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD AND A.REQ_DT = @REQ_DT AND A.WC_CD = @WC_CD AND A.LINE_CD =@LINE_CD 
      AND A.USE_FLG <> 'N' 
  )
  BEGIN 
    SELECT TOP 1 @NOW_ORDER = A.ORDER_NO FROM MT_ITEM_OUT_BATCH A WITH (NOLOCK) 
    WHERE A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD AND A.REQ_DT = @REQ_DT AND A.WC_CD = @WC_CD AND A.LINE_CD =@LINE_CD 
      AND A.USE_FLG <> 'N' 
    ORDER BY A.REQ_NO ASC

    SELECT TOP 1 @NOW_ORDER_REV = A.REVISION 
    FROM PD_ORDER A WITH (NOLOCK) 
    WHERE A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD AND A.ORDER_NO = @NOW_ORDER 
    ORDER BY A.REVISION DESC

    SET @BATCH_CHK = 'Y' -- 배정 있는것으로 판단
  END 
END 

-- 해당 공정의 투입 리스트 가지고 오기 

DECLARE @ITEM_TBL TABLE (
  CNT        INT IDENTITY(1,1)
  ,ITEM_CD   NVARCHAR(50) 

)

INSERT INTO @ITEM_TBL
SELECT A.ITEM_CD FROM PD_ORDER_USEM A WITH (NOLOCK) 
WHERE A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD AND A.ORDER_NO = @NOW_ORDER AND A.REVISION = @NOW_ORDER_REV 
  AND A.WC_CD = @WC_CD AND A.LINE_CD = @LINE_CD AND A.PROC_CD = @PROC_CD AND A.EQP_CD = @EQP_CD 

-- 최초는 지시를 선택하지 않은 상태 
-- 이때는 어떻게 표기를 해야 될까? 

-- 1. 배정이 있으면 배정 리스트를 가지고 간다. 
-- 2. 품종 구분이 필요하다.  
-- 3. 전구체냐? 리튬이냐? 이거 중요하다. 

IF @BATCH_CHK = 'Y'
BEGIN 
--  SELECT '1'

  SELECT AAA.ORDER_NO, RIGHT(AAA.REQ_DT,2) + '-' + dbo.LPAD(AAA.PLAN_SEQ,3,0) AS PLAN_SEQ, 
  AAA.QC_RESULT AS QC_CODE, 
  CCC.SUB_NM AS QC_RESULT, CCC.TEMP_CD4 AS QC_PASS, AAA.CHG_RSN, AAA.ITEM_CD AS PRNT_ITEM_CD, 
  BBB.ITEM_NM,AAA.LOT_NO, AAA.REQ_QTY, AAA.USE_FLG, AAA.REQ_NO, AAA.PLAN_SEQ AS P_SEQ, AAA.BATCH_NO,
  -- 재고 체크 
  CASE WHEN EXISTS(SELECT *FROM ST_STOCK_NOW A WITH (NOLOCK) 
  WHERE A.DIV_CD = AAA.DIV_CD AND A.PLANT_CD = AAA.PLANT_CD AND A.ITEM_CD = AAA.ITEM_CD 
  AND A.LOT_NO = AAA.LOT_NO AND ISNULL(A.RACK_CD,'*') <> '*' AND A.SL_CD = '3000' AND A.QTY > 0) THEN '재고있음'
  ELSE '재고없음' END ST_CHK,

  AAA.ITEM_TYPE,
  '0' -- 이부분 이야기가 필요함.    
  AS GBN,
  CASE WHEN AAA.REQ_QTY - AAA.USE_QTY = 0 AND AAA.USE_FLG = 'N' THEN '4' ELSE '0' END AS WORK_GBN, -- 투입 여부 확인할것 
  CONVERT(NVARCHAR(10), AAA.VFDAT, 120) AS VFDAT,
  CONVERT(NVARCHAR(10), GETDATE(), 120) AS SIL_DT, -- 실적이 있으면 뒤에 실적 일자 넣기
  AAA.ITEM_ACCT
  FROM 
  (
    SELECT AA.*
    FROM (
        SELECT E.EQP_CD, E.TP, C.REP_ITEM_CD, ISNULL(F.QC_RESULT, G.QC_RESULT) AS QC_RESULT, 
        
        H.VFDAT, D.ITEM_ACCT,
        A.*
        FROM MT_ITEM_OUT_BATCH A WITH (NOLOCK) 
        INNER JOIN 
        PD_ORDER_USEM B WITH (NOLOCK) ON A.DIV_CD = B.DIV_CD AND A.PLANT_CD = B.PLANT_CD 
        AND A.WC_CD = B.WC_CD AND A.LINE_CD = B.LINE_CD AND A.ORDER_NO = B.ORDER_NO AND B.PROC_CD = @PROC_CD 

        INNER JOIN V_ITEM C WITH (NOLOCK) ON A.PLANT_CD = C.PLANT_CD AND A.ITEM_CD = C.ITEM_CD 

        INNER JOIN V_ITEM D WITH (NOLOCK) ON B.PLANT_CD = D.PLANT_CD AND B.ITEM_CD = D.ITEM_CD 

        INNER JOIN BA_EQP E WITH (NOLOCK) ON A.ITEM_TYPE = E.TP 
        AND E.DIV_CD = @DIV_CD AND E.PLANT_CD = @PLANT_CD AND E.EQP_CD = @EQP_CD AND E.PROC_CD = @PROC_CD 

        LEFT JOIN QC_IQC_ORDER F WITH (NOLOCK) ON A.DIV_CD = F.DIV_CD 
        AND A.PLANT_CD = F.PLANT_CD AND A.ITEM_CD = F.ITEM_CD AND A.LOT_NO = F.LOT_NO 

        LEFT JOIN QC_PQC_ORDER G WITH (NOLOCK) ON A.DIV_CD =G.DIV_CD 
        AND A.PLANT_CD = G.PLANT_CD AND A.ITEM_CD = G.ITEM_CD AND A.LOT_NO = G.LOT_NO

        LEFT JOIN VIEW_VALID_DATE H WITH (NOLOCK) ON A.ITEM_CD = H.MATNR AND A.LOT_NO = H.ZVLOT 

        WHERE C.REP_ITEM_CD = D.REP_ITEM_CD 

        AND A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD AND A.WC_CD = @WC_CD AND A.LINE_CD = @LINE_CD 
        AND A.REQ_DT = @REQ_DT AND A.USE_FLG = 'N' AND ISNULL(A.CHG_RSN,'') = ''
        ORDER BY A.REQ_NO DESC
        OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY
    ) AA
    UNION ALL 

    SELECT E.EQP_CD, E.TP, C.REP_ITEM_CD, ISNULL(F.QC_RESULT, G.QC_RESULT) AS QC_RESULT, 
    
    H.VFDAT, D.ITEM_ACCT,
    A.*
    FROM MT_ITEM_OUT_BATCH A WITH (NOLOCK) 
    INNER JOIN 
    PD_ORDER_USEM B WITH (NOLOCK) ON A.DIV_CD = B.DIV_CD AND A.PLANT_CD = B.PLANT_CD 
    AND A.WC_CD = B.WC_CD AND A.LINE_CD = B.LINE_CD AND A.ORDER_NO = B.ORDER_NO AND B.PROC_CD = @PROC_CD 

    INNER JOIN V_ITEM C WITH (NOLOCK) ON A.PLANT_CD = C.PLANT_CD AND A.ITEM_CD = C.ITEM_CD 

    INNER JOIN V_ITEM D WITH (NOLOCK) ON B.PLANT_CD = D.PLANT_CD AND B.ITEM_CD = D.ITEM_CD 

    INNER JOIN BA_EQP E WITH (NOLOCK) ON A.ITEM_TYPE = E.TP 
    AND E.DIV_CD = @DIV_CD AND E.PLANT_CD = @PLANT_CD AND E.EQP_CD = @EQP_CD AND E.PROC_CD = @PROC_CD 

    LEFT JOIN QC_IQC_ORDER F WITH (NOLOCK) ON A.DIV_CD = F.DIV_CD 
    AND A.PLANT_CD = F.PLANT_CD AND A.ITEM_CD = F.ITEM_CD AND A.LOT_NO = F.LOT_NO 

    LEFT JOIN QC_PQC_ORDER G WITH (NOLOCK) ON A.DIV_CD =G.DIV_CD 
    AND A.PLANT_CD = G.PLANT_CD AND A.ITEM_CD = G.ITEM_CD AND A.LOT_NO = G.LOT_NO

    LEFT JOIN VIEW_VALID_DATE H WITH (NOLOCK) ON A.ITEM_CD = H.MATNR AND A.LOT_NO = H.ZVLOT 

    WHERE C.REP_ITEM_CD = D.REP_ITEM_CD 

      AND A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD AND A.WC_CD = @WC_CD AND A.LINE_CD = @LINE_CD 
      AND A.REQ_DT = @REQ_DT AND A.USE_FLG <> 'N' AND ISNULL(A.CHG_RSN,'') = ''

    --ORDER BY AA.REQ_NO ASC
  ) AAA 
  INNER JOIN V_ITEM BBB WITH (NOLOCK) ON AAA.PLANT_CD = BBB.PLANT_CD AND AAA.ITEM_CD = BBB.ITEM_CD 
  LEFT JOIN BA_SUB_CD CCC WITH (NOLOCK) ON AAA.QC_RESULT = CCC.SUB_CD AND CCC.MAIN_CD = 'SAP08'
  ORDER BY AAA.REQ_NO
END 
ELSE 
BEGIN
  -- 배정 없는것으로 판단, 재고 현황 
  
  SELECT AAA.ORDER_NO, AAA.QC_RESULT AS QC_CODE, BBB.SUB_CD AS QC_RESULT, BBB.TEMP_CD4 AS QC_PASS, 
  AAA.CHG_RSN, AAA.PRNT_ITEM_CD, AAA.ITEM_NM, AAA.LOT_NO, AAA.QTY, AAA.USE_FLG, AAA.REQ_NO, 
  AAA.P_SEQ, AAA.BATCH_NO, AAA.ST_CHK, AAA.ITEM_TYPE, AAA.GBN, AAA.WORK_GBN, AAA.VFDAT, AAA.SIL_DT, 
  AAA.ITEM_ACCT 
  FROM 
  (
    SELECT @NOW_ORDER AS ORDER_NO, 0 AS PLAN_SEQ, ISNULL(D.QC_RESULT, E.QC_RESULT) AS QC_RESULT, '' CHG_RSN, 
      A.ITEM_CD AS PRNT_ITEM_CD, B.ITEM_NM, A.LOT_NO, SUM(A.QTY) AS QTY , 'Y' AS USE_FLG, @NOW_ORDER AS REQ_NO, 
      @NOW_ORDER_REV AS P_SEQ, 0 AS BATCH_NO, '재고있음' AS ST_CHK, 'R' AS ITEM_TYPE, '0' AS GBN, '0' AS WORK_GBN, 
      CONVERT(NVARCHAR(10), H.VFDAT, 120) AS VFDAT, 
      CONVERT(NVARCHAR(10), GETDATE(), 120) AS SIL_DT, -- 실적이 있으면 뒤에 실적 일자 넣기
      B.ITEM_ACCT 
      FROM ST_STOCK_NOW A WITH (NOLOCK) 
      INNER JOIN V_ITEM B WITH (NOLOCK) ON A.PLANT_CD = B.PLANT_CD AND A.ITEM_CD = B.ITEM_CD 
      LEFT JOIN QC_IQC_ORDER D WITH (NOLOCK) ON A.DIV_CD = D.DIV_CD AND A.PLANT_CD = D.PLANT_CD AND A.ITEM_CD = D.ITEM_CD 
      AND A.LOT_NO = D.LOT_NO 
      LEFT JOIN QC_PQC_ORDER E WITH (NOLOCK) ON A.DIV_CD = E.DIV_CD AND A.PLANT_CD = E.PLANT_CD AND A.ITEM_CD = E.ITEM_CD 
      AND A.LOT_NO = E.LOT_NO 
      LEFT JOIN VIEW_VALID_DATE H WITH (NOLOCK) ON A.ITEM_CD = H.MATNR AND A.LOT_NO = H.ZVLOT 

    WHERE A.DIV_CD = @DIV_CD AND A.PLANT_CD = @PLANT_CD 
      AND A.ITEM_CD IN (SELECT ITEM_CD FROM @ITEM_TBL)
      AND A.SL_CD = '3000' AND A.PROC_CD = '*' AND A.RACK_CD <> '*'
      AND A.QTY > 0
    GROUP BY D.QC_RESULT, E.QC_RESULT, A.ITEM_CD, B.ITEM_NM, A.LOT_NO, H.VFDAT, B.ITEM_ACCT
  ) AAA
  INNER JOIN BA_SUB_CD BBB WITH (NOLOCK) ON AAA.QC_RESULT = BBB.SUB_CD AND BBB.MAIN_CD = 'SAP08'


  
END 

SELECT @NOW_ORDER AS ORDER_NO, @NOW_ORDER_REV AS REVISION, @BATCH_CHK AS BATCH_CHK

